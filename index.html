"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           PAYS GAME â€” Client Kivy (Mobile/Desktop)           â•‘
â•‘                                                              â•‘
â•‘  Installation :                                              â•‘
â•‘    pip install kivy websockets                               â•‘
â•‘                                                              â•‘
â•‘  Lancement :                                                 â•‘
â•‘    python main.py                                            â•‘
â•‘                                                              â•‘
â•‘  Build Android (Buildozer) :                                 â•‘
â•‘    buildozer android debug                                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import json
import random
import asyncio
import threading
import unicodedata
import uuid
from typing import Optional

import websockets
from kivy.app import App
from kivy.lang import Builder
from kivy.uix.screenmanager import ScreenManager, Screen, SlideTransition
from kivy.uix.popup import Popup
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.label import Label
from kivy.uix.textinput import TextInput
from kivy.uix.button import Button
from kivy.uix.scrollview import ScrollView
from kivy.uix.gridlayout import GridLayout
from kivy.uix.image import AsyncImage
from kivy.properties import (
    StringProperty, NumericProperty, BooleanProperty,
    ListProperty, ObjectProperty
)
from kivy.clock import Clock, mainthread
from kivy.factory import Factory
from kivy.core.window import Window
from kivy.animation import Animation
from kivy.metrics import dp
from kivy.utils import get_color_from_hex

# Taille simulateur mobile
Window.size = (390, 844)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  CONSTANTES
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# â† Changer selon ton hÃ©bergement
SERVEUR_WS   = "ws://localhost:8000"
SERVEUR_HTTP = "http://localhost:8000"

COULEUR_FOND     = get_color_from_hex("#0d0f14")
COULEUR_OCEAN    = get_color_from_hex("#0a1628")
COULEUR_CARD     = get_color_from_hex("#112240")
COULEUR_TEAL     = get_color_from_hex("#00c9a7")
COULEUR_AMBER    = get_color_from_hex("#f4a947")
COULEUR_CRIMSON  = get_color_from_hex("#e63946")
COULEUR_GOLD     = get_color_from_hex("#d4a853")
COULEUR_PAPIER   = get_color_from_hex("#f5f0e8")
COULEUR_MUTED    = get_color_from_hex("#4a5568")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  UTILITAIRES
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def normaliser(s: str) -> str:
    return unicodedata.normalize("NFD", s.upper()).encode("ascii", "ignore").decode("ascii")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  DÃ‰CLARATION DES Ã‰CRANS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class AccueilScreen(Screen):
    pass

class LobbyScreen(Screen):
    pass

class JeuScreen(Screen):
    pass

class FinScreen(Screen):
    pass


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  KV STRING
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KV = """
#:import get_color_from_hex kivy.utils.get_color_from_hex
#:import Factory kivy.factory.Factory
#:import dp kivy.metrics.dp

# â”€â”€ Widgets rÃ©utilisables â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

<BtnPrimary@Button>:
    background_normal: ''
    background_color: get_color_from_hex('#00c9a7')
    color: get_color_from_hex('#0d0f14')
    font_name: 'Roboto'
    bold: True
    size_hint_y: None
    height: dp(52)
    font_size: sp(13)

<BtnSecondary@Button>:
    background_normal: ''
    background_color: (1,1,1,0.06)
    color: get_color_from_hex('#f5f0e8')
    font_name: 'Roboto'
    size_hint_y: None
    height: dp(52)
    font_size: sp(13)
    canvas.before:
        Color:
            rgba: 1,1,1,0.1
        Line:
            rounded_rectangle: self.x, self.y, self.width, self.height, dp(10)
            width: 1

<BtnDanger@Button>:
    background_normal: ''
    background_color: (0.9,0.22,0.27,0.15)
    color: get_color_from_hex('#e63946')
    font_name: 'Roboto'
    size_hint_y: None
    height: dp(48)
    font_size: sp(12)
    canvas.before:
        Color:
            rgba: 0.9,0.22,0.27,0.3
        Line:
            rounded_rectangle: self.x, self.y, self.width, self.height, dp(10)
            width: 1

<ChampsInput@TextInput>:
    background_color: (1,1,1,0.06)
    foreground_color: get_color_from_hex('#f5f0e8')
    hint_text_color: get_color_from_hex('#4a5568')
    cursor_color: get_color_from_hex('#00c9a7')
    font_name: 'RobotoMono'
    font_size: sp(15)
    size_hint_y: None
    height: dp(48)
    padding: [dp(14), dp(12), dp(14), dp(12)]
    multiline: False

<LabelTitre@Label>:
    font_name: 'Roboto'
    bold: True
    color: get_color_from_hex('#f5f0e8')

<LabelMono@Label>:
    font_name: 'RobotoMono'
    color: get_color_from_hex('#4a5568')
    font_size: sp(11)

<ToucheClavier@Button>:
    background_normal: ''
    background_color: (1,1,1,0.06)
    color: get_color_from_hex('#f5f0e8')
    font_name: 'RobotoMono'
    font_size: sp(13)
    bold: True
    canvas.before:
        Color:
            rgba: 1,1,1,0.08
        Line:
            rounded_rectangle: self.x+1, self.y+1, self.width-2, self.height-2, dp(6)
            width: 1

# â”€â”€ GESTIONNAIRE D'Ã‰CRANS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ScreenManager:
    id: sm
    transition: SlideTransition()
    AccueilScreen:
    LobbyScreen:
    JeuScreen:
    FinScreen:

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  Ã‰CRAN 1 â€” ACCUEIL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

<AccueilScreen>:
    name: 'accueil'
    canvas.before:
        Color:
            rgba: get_color_from_hex('#0a1628')
        Rectangle:
            pos: self.pos
            size: self.size

    ScrollView:
        BoxLayout:
            orientation: 'vertical'
            padding: dp(24)
            spacing: dp(16)
            size_hint_y: None
            height: self.minimum_height

            # Logo
            BoxLayout:
                orientation: 'vertical'
                size_hint_y: None
                height: dp(140)
                spacing: dp(4)
                padding: [0, dp(20), 0, 0]

                Label:
                    text: "ğŸŒ"
                    font_size: sp(48)
                    size_hint_y: None
                    height: dp(60)

                Label:
                    text: "PAYS GAME"
                    font_name: 'Roboto'
                    bold: True
                    font_size: sp(32)
                    color: get_color_from_hex('#d4a853')
                    size_hint_y: None
                    height: dp(44)

                Label:
                    text: "LE JEU DES NATIONS"
                    font_name: 'RobotoMono'
                    font_size: sp(10)
                    letter_spacing: dp(3)
                    color: get_color_from_hex('#00c9a7')
                    size_hint_y: None
                    height: dp(20)

            # Carte formulaire
            BoxLayout:
                orientation: 'vertical'
                spacing: dp(12)
                size_hint_y: None
                height: self.minimum_height
                canvas.before:
                    Color:
                        rgba: get_color_from_hex('#112240')
                    RoundedRectangle:
                        pos: self.pos
                        size: self.size
                        radius: [dp(16)]
                padding: dp(20)

                LabelMono:
                    text: "TON NOM"
                    size_hint_y: None
                    height: dp(20)
                    color: get_color_from_hex('#00c9a7')

                ChampsInput:
                    id: input_nom
                    hint_text: "Ex: Alice"

                # Ligne langue + vies
                GridLayout:
                    cols: 2
                    spacing: dp(10)
                    size_hint_y: None
                    height: dp(90)

                    BoxLayout:
                        orientation: 'vertical'
                        spacing: dp(6)
                        LabelMono:
                            text: "LANGUE"
                            color: get_color_from_hex('#00c9a7')
                            size_hint_y: None
                            height: dp(18)
                        Spinner:
                            id: spin_langue
                            values: ['FranÃ§ais ğŸ‡«ğŸ‡·', 'English ğŸ‡¬ğŸ‡§']
                            text: 'FranÃ§ais ğŸ‡«ğŸ‡·'
                            background_normal: ''
                            background_color: (1,1,1,0.06)
                            color: get_color_from_hex('#f5f0e8')
                            font_name: 'Roboto'
                            size_hint_y: None
                            height: dp(48)

                    BoxLayout:
                        orientation: 'vertical'
                        spacing: dp(6)
                        LabelMono:
                            text: "VIES"
                            color: get_color_from_hex('#00c9a7')
                            size_hint_y: None
                            height: dp(18)
                        Spinner:
                            id: spin_vies
                            values: ['5 vies', '10 vies', '15 vies']
                            text: '10 vies'
                            background_normal: ''
                            background_color: (1,1,1,0.06)
                            color: get_color_from_hex('#f5f0e8')
                            font_name: 'Roboto'
                            size_hint_y: None
                            height: dp(48)

                # Ligne chrono + mode mixte
                GridLayout:
                    cols: 2
                    spacing: dp(10)
                    size_hint_y: None
                    height: dp(90)

                    BoxLayout:
                        orientation: 'vertical'
                        spacing: dp(6)
                        LabelMono:
                            text: "CHRONO"
                            color: get_color_from_hex('#00c9a7')
                            size_hint_y: None
                            height: dp(18)
                        Spinner:
                            id: spin_temps
                            values: ['10 sec', '15 sec', '30 sec', '60 sec']
                            text: '15 sec'
                            background_normal: ''
                            background_color: (1,1,1,0.06)
                            color: get_color_from_hex('#f5f0e8')
                            font_name: 'Roboto'
                            size_hint_y: None
                            height: dp(48)

                    BoxLayout:
                        orientation: 'vertical'
                        spacing: dp(6)
                        LabelMono:
                            text: "MODE MIXTE"
                            color: get_color_from_hex('#00c9a7')
                            size_hint_y: None
                            height: dp(18)
                        Switch:
                            id: switch_mixte
                            active: False
                            size_hint_y: None
                            height: dp(48)

                BtnPrimary:
                    text: "ğŸ—ºï¸  CRÃ‰ER UNE PARTIE"
                    on_release: app.creer_partie()

                BoxLayout:
                    size_hint_y: None
                    height: dp(30)
                    Label:
                        text: "â”€â”€ ou rejoindre â”€â”€"
                        color: get_color_from_hex('#4a5568')
                        font_size: sp(12)

                ChampsInput:
                    id: input_room
                    hint_text: "Code salle (ex: ABCDEF)"

                BtnSecondary:
                    text: "Rejoindre â†’"
                    on_release: app.rejoindre_par_code()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  Ã‰CRAN 2 â€” LOBBY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

<LobbyScreen>:
    name: 'lobby'
    canvas.before:
        Color:
            rgba: get_color_from_hex('#0a1628')
        Rectangle:
            pos: self.pos
            size: self.size

    BoxLayout:
        orientation: 'vertical'
        padding: dp(24)
        spacing: dp(16)

        # En-tÃªte
        BoxLayout:
            orientation: 'vertical'
            size_hint_y: None
            height: dp(100)
            spacing: dp(8)

            LabelTitre:
                text: "SALLE D'ATTENTE"
                font_size: sp(22)
                halign: 'center'

            Label:
                id: lbl_room_code
                text: app.room_id
                font_name: 'RobotoMono'
                font_size: sp(28)
                bold: True
                color: get_color_from_hex('#d4a853')
                halign: 'center'
                letter_spacing: dp(6)

            Label:
                id: lbl_lien
                text: "Appuyez pour copier le lien"
                font_name: 'RobotoMono'
                font_size: sp(10)
                color: get_color_from_hex('#00c9a7')
                halign: 'center'
                on_touch_down: if self.collide_point(*args[1].pos): app.copier_lien()

        # Liste joueurs
        ScrollView:
            GridLayout:
                id: grid_joueurs
                cols: 2
                spacing: dp(10)
                padding: [0, dp(4)]
                size_hint_y: None
                height: self.minimum_height

        # Actions
        BoxLayout:
            orientation: 'vertical'
            size_hint_y: None
            height: dp(180)
            spacing: dp(10)

            BtnSecondary:
                text: "ğŸ¤–  Ajouter un bot"
                on_release: app.ajouter_ia()

            BtnPrimary:
                id: btn_demarrer
                text: "â–¶  LANCER LA PARTIE"
                on_release: app.demarrer_partie()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  Ã‰CRAN 3 â€” JEU
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

<JeuScreen>:
    name: 'jeu'
    canvas.before:
        Color:
            rgba: get_color_from_hex('#0a1628')
        Rectangle:
            pos: self.pos
            size: self.size

    BoxLayout:
        orientation: 'vertical'
        spacing: 0

        # Barre scores
        BoxLayout:
            id: scores_bar
            size_hint_y: None
            height: dp(72)
            canvas.before:
                Color:
                    rgba: get_color_from_hex('#112240')
                Rectangle:
                    pos: self.pos
                    size: self.size

        # Barre chrono
        BoxLayout:
            size_hint_y: None
            height: dp(4)
            canvas.before:
                Color:
                    rgba: 1,1,1,0.06
                Rectangle:
                    pos: self.pos
                    size: self.size
            Widget:
                id: chrono_fill
                size_hint_x: 1
                canvas:
                    Color:
                        rgba: app.couleur_chrono
                    Rectangle:
                        pos: self.pos
                        size: self.size

        # Zone centrale
        BoxLayout:
            orientation: 'vertical'
            padding: [dp(16), dp(12)]
            spacing: dp(12)

            # SÃ©quence de lettres
            BoxLayout:
                orientation: 'vertical'
                size_hint_y: None
                height: dp(90)
                spacing: dp(6)

                Label:
                    id: lbl_sequence
                    text: app.lettres_en_cours if app.lettres_en_cours else "â€¦"
                    font_name: 'Roboto'
                    bold: True
                    font_size: sp(36)
                    color: app.couleur_sequence
                    halign: 'center'
                    letter_spacing: dp(6)

                Label:
                    id: lbl_tour
                    text: app.indicateur_tour
                    font_name: 'RobotoMono'
                    font_size: sp(11)
                    color: get_color_from_hex('#00c9a7')
                    halign: 'center'

                Label:
                    id: lbl_poss
                    text: app.nb_possibilites
                    font_name: 'RobotoMono'
                    font_size: sp(10)
                    color: get_color_from_hex('#4a5568')
                    halign: 'center'

            # Historique drapeaux
            ScrollView:
                size_hint_y: None
                height: dp(60)
                do_scroll_y: False
                GridLayout:
                    id: historique_drapeaux
                    rows: 1
                    spacing: dp(8)
                    padding: [dp(4), 0]
                    size_hint_x: None
                    width: self.minimum_width

            # Clavier
            GridLayout:
                id: clavier_grille
                cols: 7
                spacing: dp(4)
                size_hint_y: None
                height: dp(200)

            # Bouton langue au chat
            BtnDanger:
                id: btn_langue
                text: "ğŸ—£  DONNER MA LANGUE AU CHAT"
                on_release: app.demander_langue_au_chat()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  Ã‰CRAN 4 â€” FIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

<FinScreen>:
    name: 'fin'
    canvas.before:
        Color:
            rgba: get_color_from_hex('#0a1628')
        Rectangle:
            pos: self.pos
            size: self.size

    BoxLayout:
        orientation: 'vertical'
        padding: dp(32)
        spacing: dp(24)
        halign: 'center'

        Label:
            text: "ğŸ‘‘"
            font_size: sp(64)
            size_hint_y: None
            height: dp(80)

        BoxLayout:
            orientation: 'vertical'
            size_hint_y: None
            height: dp(80)
            Label:
                text: "VAINQUEUR"
                font_name: 'RobotoMono'
                font_size: sp(11)
                color: get_color_from_hex('#00c9a7')
                letter_spacing: dp(3)
            Label:
                id: lbl_gagnant
                text: app.nom_gagnant
                font_name: 'Roboto'
                bold: True
                font_size: sp(32)
                color: get_color_from_hex('#d4a853')

        # Stats
        GridLayout:
            cols: 3
            spacing: dp(10)
            size_hint_y: None
            height: dp(90)

            BoxLayout:
                orientation: 'vertical'
                canvas.before:
                    Color:
                        rgba: 1,1,1,0.04
                    RoundedRectangle:
                        pos: self.pos
                        size: self.size
                        radius: [dp(10)]
                Label:
                    id: stat_pays
                    text: "0"
                    font_name: 'Roboto'
                    bold: True
                    font_size: sp(28)
                    color: get_color_from_hex('#00c9a7')
                Label:
                    text: "PAYS"
                    font_name: 'RobotoMono'
                    font_size: sp(9)
                    color: get_color_from_hex('#4a5568')

            BoxLayout:
                orientation: 'vertical'
                canvas.before:
                    Color:
                        rgba: 1,1,1,0.04
                    RoundedRectangle:
                        pos: self.pos
                        size: self.size
                        radius: [dp(10)]
                Label:
                    id: stat_tours
                    text: "0"
                    font_name: 'Roboto'
                    bold: True
                    font_size: sp(28)
                    color: get_color_from_hex('#00c9a7')
                Label:
                    text: "TOURS"
                    font_name: 'RobotoMono'
                    font_size: sp(9)
                    color: get_color_from_hex('#4a5568')

            BoxLayout:
                orientation: 'vertical'
                canvas.before:
                    Color:
                        rgba: 1,1,1,0.04
                    RoundedRectangle:
                        pos: self.pos
                        size: self.size
                        radius: [dp(10)]
                Label:
                    id: stat_vies
                    text: "0"
                    font_name: 'Roboto'
                    bold: True
                    font_size: sp(28)
                    color: get_color_from_hex('#00c9a7')
                Label:
                    text: "VIES"
                    font_name: 'RobotoMono'
                    font_size: sp(9)
                    color: get_color_from_hex('#4a5568')

        Widget:

        BtnSecondary:
            text: "â† Accueil"
            on_release: app.retour_accueil()

        BtnPrimary:
            text: "â†º  Rejouer"
            on_release: app.rejouer()
"""


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  APPLICATION PRINCIPALE
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class PaysGameApp(App):

    # â”€â”€ Properties (liÃ©es au KV) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    room_id           = StringProperty("â€”â€”")
    lettres_en_cours  = StringProperty("")
    indicateur_tour   = StringProperty("En attenteâ€¦")
    nb_possibilites   = StringProperty("")
    nom_gagnant       = StringProperty("â€”")
    couleur_sequence  = ListProperty([0.96, 0.94, 0.91, 1])   # papier
    couleur_chrono    = ListProperty([0, 0.79, 0.66, 1])        # teal

    # â”€â”€ Ã‰tat interne â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.joueur_id     = str(uuid.uuid4())
        self.nom_joueur    = "Joueur"
        self.langue        = "fr"
        self.mode_mixte    = False
        self.temps_max     = 15
        self.vies_depart   = 10
        self.est_createur  = False
        self.mode_connecte = False

        self.ws            = None          # WebSocket actif
        self.ws_loop       = None          # event loop asyncio dÃ©diÃ©
        self.ws_thread     = None

        self.pays_local    = []
        self.pays_joues    = set()
        self.pays_joues_liste = []

        # Ã‰tat solo
        self.joueurs_solo  = []
        self.index_tour    = 0
        self.sequence      = ""
        self.est_mon_tour  = False
        self.joueur_fautif = None
        self.nb_tours      = 0

        self._chrono_event = None
        self._temps_restant = 15

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  BUILD
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def build(self):
        self.root = Builder.load_string(KV)
        return self.root

    def on_start(self):
        self._charger_pays_local("fr")
        self._lancer_loop_asyncio()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  LOOP ASYNCIO (thread dÃ©diÃ© pour WebSockets)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _lancer_loop_asyncio(self):
        self.ws_loop = asyncio.new_event_loop()
        self.ws_thread = threading.Thread(
            target=self.ws_loop.run_forever,
            daemon=True
        )
        self.ws_thread.start()

    def _run_async(self, coro):
        """Lance une coroutine dans la loop dÃ©diÃ©e."""
        asyncio.run_coroutine_threadsafe(coro, self.ws_loop)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  DONNÃ‰ES PAYS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _charger_pays_local(self, langue: str):
        try:
            with open(f"pays_{langue}.json", "r", encoding="utf-8") as f:
                self.pays_local = json.load(f)
        except FileNotFoundError:
            self.pays_local = [
                {"nom": "FRANCE", "capitale": "PARIS", "code": "fr",
                 "nom_normalise": "FRANCE", "capitale_normalisee": "PARIS"},
                {"nom": "ALLEMAGNE", "capitale": "BERLIN", "code": "de",
                 "nom_normalise": "ALLEMAGNE", "capitale_normalisee": "BERLIN"},
                {"nom": "ESPAGNE", "capitale": "MADRID", "code": "es",
                 "nom_normalise": "ESPAGNE", "capitale_normalisee": "MADRID"},
                {"nom": "ITALIE", "capitale": "ROME", "code": "it",
                 "nom_normalise": "ITALIE", "capitale_normalisee": "ROME"},
                {"nom": "CANADA", "capitale": "OTTAWA", "code": "ca",
                 "nom_normalise": "CANADA", "capitale_normalisee": "OTTAWA"},
                {"nom": "CHINE", "capitale": "PEKIN", "code": "cn",
                 "nom_normalise": "CHINE", "capitale_normalisee": "PEKIN"},
                {"nom": "JAPON", "capitale": "TOKYO", "code": "jp",
                 "nom_normalise": "JAPON", "capitale_normalisee": "TOKYO"},
                {"nom": "BELGIQUE", "capitale": "BRUXELLES", "code": "be",
                 "nom_normalise": "BELGIQUE", "capitale_normalisee": "BRUXELLES"},
            ]
            self._toast("âš ï¸ Fichier pays non trouvÃ© â€” mode dÃ©mo")

    def _chercher_possibilites(self, seq: str):
        if not seq:
            return self.pays_local
        s = normaliser(seq)
        return [
            p for p in self.pays_local
            if p["nom_normalise"].startswith(s)
            or (self.mode_mixte and p.get("capitale_normalisee", "").startswith(s))
        ]

    def _est_complet(self, seq: str):
        s = normaliser(seq)
        for p in self.pays_local:
            if p["nom_normalise"] == s:
                return p
            if self.mode_mixte and p.get("capitale_normalisee") == s:
                return p
        return None

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  ACCUEIL
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _lire_config(self):
        ecran = self.root.get_screen("accueil")
        self.nom_joueur = ecran.ids.input_nom.text.strip() or "Joueur"
        self.langue     = "fr" if "FranÃ§ais" in ecran.ids.spin_langue.text else "en"
        self.mode_mixte = ecran.ids.switch_mixte.active
        self.temps_max  = int(ecran.ids.spin_temps.text.split()[0])
        self.vies_depart = int(ecran.ids.spin_vies.text.split()[0])
        self._charger_pays_local(self.langue)

    def creer_partie(self):
        self._lire_config()
        self.est_createur = True
        self._run_async(self._tenter_connexion_serveur(creer=True))

    def rejoindre_par_code(self):
        self._lire_config()
        ecran = self.root.get_screen("accueil")
        code = ecran.ids.input_room.text.strip().upper()
        if len(code) != 6:
            self._toast("Code invalide (6 lettres)", "error")
            return
        self.est_createur = False
        self.room_id = code
        self._run_async(self._tenter_connexion_serveur(creer=False))

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  WEBSOCKET
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def _tenter_connexion_serveur(self, creer: bool):
        try:
            if creer:
                import urllib.request
                config = {
                    "langue": self.langue,
                    "mode_mixte": self.mode_mixte,
                    "vies": self.vies_depart,
                    "temps": self.temps_max,
                    "max_joueurs": 8,
                }
                req = urllib.request.Request(
                    f"{SERVEUR_HTTP}/parties",
                    data=json.dumps(config).encode(),
                    headers={"Content-Type": "application/json"},
                    method="POST"
                )
                with urllib.request.urlopen(req, timeout=4) as resp:
                    data = json.loads(resp.read())
                self.room_id = data["room_id"]

            uri = f"{SERVEUR_WS}/ws/{self.room_id}/{self.joueur_id}/{self.nom_joueur}"
            async with websockets.connect(uri, ping_interval=20) as ws:
                self.ws = ws
                self.mode_connecte = True
                Clock.schedule_once(lambda dt: self._afficher_lobby(), 0)
                await self._recevoir_messages(ws)

        except Exception as e:
            self.ws = None
            self.mode_connecte = False
            Clock.schedule_once(lambda dt: self._lancer_mode_solo(), 0)

    async def _recevoir_messages(self, ws):
        try:
            async for raw in ws:
                msg = json.loads(raw)
                Clock.schedule_once(lambda dt, m=msg: self._traiter_message(m), 0)
        except websockets.ConnectionClosed:
            Clock.schedule_once(lambda dt: self._toast("ğŸ”Œ DÃ©connectÃ©", "error"), 0)

    def _envoyer_ws(self, data: dict):
        if self.ws and self.mode_connecte:
            self._run_async(self.ws.send(json.dumps(data)))

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  TRAITEMENT MESSAGES SERVEUR
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _traiter_message(self, msg: dict):
        t = msg.get("type", "")

        if t in ("etat", "joueur_rejoint", "joueur_parti"):
            self._sync_etat(msg)

        elif t == "partie_demarree":
            self._sync_etat(msg)
            self._aller_ecran("jeu")
            self._toast("ğŸ® La partie commence !")

        elif t == "nouveau_tour":
            self._sync_etat(msg)
            self._lancer_chrono(msg.get("config", {}).get("temps", self.temps_max))
            self.nb_tours += 1

        elif t == "sequence_invalide":
            self._sync_etat(msg)
            self._flash_sequence(invalide=True)
            self._toast(msg.get("message", ""), "warn")

        elif t == "mot_complet":
            self._sync_etat(msg)
            self._flash_sequence(complet=True)
            self._ajouter_drapeau(msg.get("pays", {}))
            self._toast(msg.get("message", ""), "warn")

        elif t == "langue_au_chat":
            self._sync_etat(msg)
            if msg.get("interpelle") == self.joueur_id:
                Clock.schedule_once(
                    lambda dt: self._ouvrir_modal_langue(msg.get("message", "")), 0
                )
            else:
                self._toast(msg.get("message", ""), "warn")

        elif t == "verdict_langue_au_chat":
            self._afficher_verdict(msg)

        elif t == "perte_vie":
            self._sync_etat(msg)
            self._toast(msg.get("message", ""), "error" if msg.get("elimine") else "warn")

        elif t == "fin_partie":
            self._sync_etat(msg)
            self._afficher_fin(msg)

        elif t == "chat":
            self._ajouter_chat(msg)

    def _sync_etat(self, msg: dict):
        """Met Ã  jour l'UI depuis un snapshot serveur."""
        seq = msg.get("sequence", "")
        self.lettres_en_cours = (" Â· ".join(seq)) if seq else ""

        actuel = msg.get("joueur_actuel")
        self.est_mon_tour = actuel == self.joueur_id

        joueurs = msg.get("joueurs", [])
        nom_actuel = next((j["nom"] for j in joueurs if j["id"] == actuel), "")
        self.indicateur_tour = "â¬‡ Ton tour !" if self.est_mon_tour else f"Tour de {nom_actuel}"

        if seq:
            poss = self._chercher_possibilites(seq)
            self.nb_possibilites = f"{len(poss)} pays possible{'s' if len(poss) > 1 else ''}" if poss else ""
        else:
            self.nb_possibilites = ""

        self._mettre_a_jour_scores(msg)
        self._activer_clavier(self.est_mon_tour)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  LOBBY
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _afficher_lobby(self):
        self._aller_ecran("lobby")
        ecran = self.root.get_screen("lobby")
        ecran.ids.lbl_room_code.text = self.room_id
        ecran.ids.btn_demarrer.disabled = not self.est_createur

    def copier_lien(self):
        from kivy.core.clipboard import Clipboard
        lien = f"pays-game://rejoindre/{self.room_id}"
        Clipboard.copy(lien)
        self._toast("ğŸ”— Lien copiÃ© !")

    def _mettre_a_jour_grille_joueurs(self, joueurs: list):
        try:
            grid = self.root.get_screen("lobby").ids.grid_joueurs
        except Exception:
            return
        grid.clear_widgets()
        avatars = ['ğŸ§‘', 'ğŸ‘©', 'ğŸ§”', 'ğŸ‘±', 'ğŸ§•', 'ğŸ‘¨â€ğŸ’»', 'ğŸ§™', 'ğŸ¦Š']
        for i, j in enumerate(joueurs):
            card = BoxLayout(orientation='vertical', padding=dp(12), spacing=dp(4),
                             size_hint_y=None, height=dp(80))
            with card.canvas.before:
                from kivy.graphics import Color, RoundedRectangle
                Color(rgba=(1, 1, 1, 0.04))
                self._rr = RoundedRectangle(pos=card.pos, size=card.size, radius=[dp(10)])
            card.add_widget(Label(
                text=f"{'ğŸ¤–' if j.get('est_ia') else avatars[i % len(avatars)]}",
                font_size='24sp'
            ))
            card.add_widget(Label(
                text=j['nom'], font_name='Roboto', font_size='13sp',
                color=COULEUR_PAPIER, bold=True
            ))
            tag = 'BOT' if j.get('est_ia') else ('MOI' if j['id'] == self.joueur_id else 'EN LIGNE')
            card.add_widget(Label(
                text=tag, font_name='RobotoMono', font_size='10sp',
                color=COULEUR_TEAL
            ))
            grid.add_widget(card)

    def ajouter_ia(self):
        if self.mode_connecte:
            import urllib.request
            try:
                req = urllib.request.Request(
                    f"{SERVEUR_HTTP}/parties/{self.room_id}/ia",
                    method="POST"
                )
                urllib.request.urlopen(req, timeout=3)
            except Exception:
                self._toast("Serveur indisponible", "error")
        else:
            self._ajouter_ia_locale()

    def demarrer_partie(self):
        if self.mode_connecte:
            import urllib.request
            try:
                req = urllib.request.Request(
                    f"{SERVEUR_HTTP}/parties/{self.room_id}/demarrer?joueur_id={self.joueur_id}",
                    method="POST"
                )
                urllib.request.urlopen(req, timeout=3)
            except Exception:
                self._toast("Erreur serveur", "error")
        else:
            self._demarrer_solo()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  CLAVIER
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _construire_clavier(self):
        try:
            grille = self.root.get_screen("jeu").ids.clavier_grille
        except Exception:
            return
        grille.clear_widgets()
        for lettre in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
            btn = Factory.ToucHEClavier(text=lettre)
            btn.bind(on_release=lambda inst, l=lettre: self._appuyer_touche(l))
            grille.add_widget(btn)

    def _activer_clavier(self, actif: bool):
        try:
            grille = self.root.get_screen("jeu").ids.clavier_grille
            btn_langue = self.root.get_screen("jeu").ids.btn_langue
        except Exception:
            return
        for child in grille.children:
            child.disabled = not actif
        btn_langue.disabled = actif  # langue au chat = quand c'est PAS mon tour

    def _appuyer_touche(self, lettre: str):
        if not self.est_mon_tour:
            return
        if self.mode_connecte:
            self._envoyer_ws({"action": "lettre", "lettre": lettre})
        else:
            self._traiter_lettre_solo(lettre)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  CHRONO
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _lancer_chrono(self, secondes: int):
        if self._chrono_event:
            self._chrono_event.cancel()
        self._temps_restant = secondes
        self.temps_max = secondes
        self._tick_chrono(0)
        self._chrono_event = Clock.schedule_interval(self._tick_chrono, 1)

    def _tick_chrono(self, dt):
        try:
            fill = self.root.get_screen("jeu").ids.chrono_fill
        except Exception:
            return
        pct = self._temps_restant / max(self.temps_max, 1)
        fill.width = fill.parent.width * pct

        if self._temps_restant <= 5:
            self.couleur_chrono = [0.9, 0.22, 0.27, 1]  # crimson
        else:
            self.couleur_chrono = [0, 0.79, 0.66, 1]  # teal

        self._temps_restant -= 1
        if self._temps_restant < 0:
            if self._chrono_event:
                self._chrono_event.cancel()
            if not self.mode_connecte and self.est_mon_tour:
                self._perdre_vie_solo(self.joueur_id, "â° Temps Ã©coulÃ© !")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  SCORES
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _mettre_a_jour_scores(self, msg: dict):
        try:
            bar = self.root.get_screen("jeu").ids.scores_bar
        except Exception:
            return
        bar.clear_widgets()
        joueurs = msg.get("joueurs", [])
        actuel  = msg.get("joueur_actuel")
        vies_max = msg.get("config", {}).get("vies", self.vies_depart)

        for i, j in enumerate(joueurs):
            actif = j["id"] == actuel
            col = BoxLayout(orientation='vertical', padding=[dp(10), dp(8)], spacing=dp(4))

            # Fond actif
            if actif:
                with col.canvas.before:
                    from kivy.graphics import Color, Rectangle
                    Color(rgba=(0, 0.79, 0.66, 0.08))
                    Rectangle(pos=col.pos, size=col.size)

            col.add_widget(Label(
                text=f"{'ğŸ¤–' if j.get('est_ia') else ''}{j['nom']}",
                font_name='RobotoMono',
                font_size='10sp',
                color=COULEUR_TEAL if actif else (*COULEUR_MUTED[:3], 0.7),
                bold=actif,
                halign='center',
                size_hint_y=None,
                height=dp(18)
            ))

            # Points de vie
            dots_layout = BoxLayout(size_hint_y=None, height=dp(12), spacing=dp(3))
            dots_layout.bind(minimum_width=dots_layout.setter('width'))
            for k in range(vies_max):
                from kivy.uix.widget import Widget
                from kivy.graphics import Color, Ellipse
                dot = Widget(size_hint=(None, None), size=(dp(8), dp(8)))
                with dot.canvas:
                    Color(rgba=COULEUR_CRIMSON if k < j["vies"] else (1, 1, 1, 0.1))
                    Ellipse(pos=dot.pos, size=dot.size)
                dots_layout.add_widget(dot)

            col.add_widget(dots_layout)
            bar.add_widget(col)

            if i < len(joueurs) - 1:
                bar.add_widget(Label(
                    text="VS", font_name='RobotoMono', font_size='10sp',
                    color=COULEUR_MUTED, size_hint_x=None, width=dp(30)
                ))

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  DRAPEAUX
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _ajouter_drapeau(self, pays: dict):
        if not pays:
            return
        try:
            histo = self.root.get_screen("jeu").ids.historique_drapeaux
        except Exception:
            return

        col = BoxLayout(orientation='vertical', size_hint=(None, 1), width=dp(56),
                        spacing=dp(2), padding=[0, dp(2)])
        col.add_widget(AsyncImage(
            source=f"https://flagcdn.com/w80/{pays.get('code','fr')}.png",
            size_hint=(1, None),
            height=dp(36),
            allow_stretch=True,
            keep_ratio=True
        ))
        col.add_widget(Label(
            text=pays.get('nom', '')[:8],
            font_name='RobotoMono',
            font_size='7sp',
            color=COULEUR_MUTED,
            halign='center'
        ))
        histo.add_widget(col)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  LANGUE AU CHAT
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def demander_langue_au_chat(self):
        if self.mode_connecte:
            self._envoyer_ws({"action": "langue_au_chat"})
        else:
            self._demander_langue_locale()

    def _ouvrir_modal_langue(self, texte: str = ""):
        content = BoxLayout(orientation='vertical', padding=dp(20), spacing=dp(14))
        content.add_widget(Label(
            text="ğŸ—£ï¸", font_size='40sp', size_hint_y=None, height=dp(52)
        ))
        content.add_widget(Label(
            text="Langue au chat !",
            font_name='Roboto', bold=True, font_size='18sp',
            color=COULEUR_PAPIER, size_hint_y=None, height=dp(28)
        ))
        content.add_widget(Label(
            text=texte or "Quel pays avais-tu en tÃªte ?",
            font_name='Roboto', font_size='13sp',
            color=(*COULEUR_PAPIER[:3], 0.7),
            size_hint_y=None, height=dp(48),
            text_size=(dp(280), None), halign='center'
        ))
        saisie = TextInput(
            hint_text="FRANCEâ€¦",
            font_name='RobotoMono',
            font_size='18sp',
            halign='center',
            background_color=(1, 1, 1, 0.06),
            foreground_color=COULEUR_PAPIER,
            size_hint_y=None, height=dp(52),
            multiline=False
        )
        content.add_widget(saisie)

        popup = Popup(
            title="",
            content=content,
            size_hint=(0.9, None),
            height=dp(340),
            background_color=(*COULEUR_CARD[:3], 0.98),
            separator_height=0,
        )

        btn_valider = Button(
            text="Valider",
            background_normal='',
            background_color=COULEUR_TEAL,
            color=COULEUR_FOND,
            font_name='Roboto', bold=True,
            size_hint_y=None, height=dp(48)
        )

        def valider(instance):
            rep = saisie.text.strip()
            popup.dismiss()
            if self.mode_connecte:
                self._envoyer_ws({"action": "reponse_langue_au_chat", "pays": rep})
            else:
                self._evaluer_reponse_locale(rep)

        btn_valider.bind(on_release=valider)
        saisie.bind(on_text_validate=valider)
        content.add_widget(btn_valider)
        popup.open()
        Clock.schedule_once(lambda dt: saisie.focus.__set__(saisie, True), 0.1)

    def _afficher_verdict(self, msg: dict):
        valide = msg.get("valide", False)
        content = BoxLayout(orientation='vertical', padding=dp(20), spacing=dp(12))
        content.add_widget(Label(
            text="âœ…" if valide else "âŒ",
            font_size='40sp', size_hint_y=None, height=dp(52)
        ))
        content.add_widget(Label(
            text="Bravo !" if valide else "Perdu !",
            font_name='Roboto', bold=True, font_size='18sp',
            color=COULEUR_TEAL if valide else COULEUR_CRIMSON,
            size_hint_y=None, height=dp(28)
        ))
        content.add_widget(Label(
            text=msg.get("message", ""),
            font_name='Roboto', font_size='13sp',
            color=(*COULEUR_PAPIER[:3], 0.8),
            size_hint_y=None, height=dp(60),
            text_size=(dp(280), None), halign='center'
        ))
        popup = Popup(
            title="", content=content,
            size_hint=(0.85, None), height=dp(250),
            background_color=(*COULEUR_CARD[:3], 0.98),
            separator_height=0,
            auto_dismiss=True
        )
        btn = Button(
            text="OK",
            background_normal='', background_color=COULEUR_TEAL,
            color=COULEUR_FOND, font_name='Roboto', bold=True,
            size_hint_y=None, height=dp(46)
        )
        btn.bind(on_release=lambda x: popup.dismiss())
        content.add_widget(btn)
        popup.open()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  TOASTS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _toast(self, texte: str, niveau: str = ""):
        couleurs = {
            "error": COULEUR_CRIMSON,
            "warn":  COULEUR_AMBER,
            "":      COULEUR_TEAL,
        }
        couleur = couleurs.get(niveau, COULEUR_TEAL)

        content = BoxLayout(padding=[dp(14), dp(10)])
        content.add_widget(Label(
            text=texte,
            font_name='Roboto',
            font_size='13sp',
            color=COULEUR_PAPIER,
            text_size=(Window.width * 0.75, None),
            halign='center'
        ))
        popup = Popup(
            title="", content=content,
            size_hint=(0.85, None), height=dp(64),
            background_color=(0.07, 0.09, 0.12, 0.95),
            separator_height=0,
            auto_dismiss=True
        )
        with popup.canvas.before:
            from kivy.graphics import Color, Line
            Color(rgba=couleur)
            Line(rectangle=(popup.x, popup.y, popup.width, popup.height), width=1.5)

        popup.open()
        Clock.schedule_once(lambda dt: popup.dismiss(), 3.0)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  ANIMATIONS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _flash_sequence(self, invalide=False, complet=False):
        if invalide:
            self.couleur_sequence = [*COULEUR_CRIMSON[:3], 1]
        elif complet:
            self.couleur_sequence = [*COULEUR_TEAL[:3], 1]
        Clock.schedule_once(
            lambda dt: setattr(self, 'couleur_sequence', [0.96, 0.94, 0.91, 1]), 0.6
        )

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  MODE SOLO â€” IA LOCALE
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _lancer_mode_solo(self):
        self.mode_connecte = False
        self.joueurs_solo = [
            {"id": self.joueur_id, "nom": self.nom_joueur,
             "vies": self.vies_depart, "en_vie": True, "est_ia": False},
            {"id": "ia", "nom": "ğŸ¤– Ordinateur",
             "vies": self.vies_depart, "en_vie": True, "est_ia": True},
        ]
        self.index_tour   = 0
        self.sequence     = ""
        self.pays_joues   = set()
        self.pays_joues_liste = []
        self.nb_tours     = 0
        self.joueur_fautif = None

        self.room_id = "SOLO"
        self._afficher_lobby()
        ecran = self.root.get_screen("lobby")
        ecran.ids.btn_demarrer.disabled = False
        self._mettre_a_jour_grille_joueurs(self.joueurs_solo)
        self._toast("ğŸ”Œ Serveur non disponible â€” mode solo vs IA", "warn")

    def _ajouter_ia_locale(self):
        if len(self.joueurs_solo) >= 4:
            return
        self.joueurs_solo.append({
            "id": f"ia{len(self.joueurs_solo)}",
            "nom": "ğŸ¤– Bot",
            "vies": self.vies_depart,
            "en_vie": True,
            "est_ia": True,
        })
        self._mettre_a_jour_grille_joueurs(self.joueurs_solo)

    def _demarrer_solo(self):
        self._aller_ecran("jeu")
        self._construire_clavier()
        self._nouveau_tour_solo()

    def _joueur_actuel_solo(self):
        return self.joueurs_solo[self.index_tour]

    def _nouveau_tour_solo(self):
        self.sequence = ""
        self.joueur_fautif = None
        self.nb_tours += 1
        j = self._joueur_actuel_solo()
        self.est_mon_tour = j["id"] == self.joueur_id

        snap = {
            "sequence": "",
            "joueur_actuel": j["id"],
            "joueurs": self.joueurs_solo,
            "config": {"vies": self.vies_depart},
        }
        self._sync_etat(snap)
        self._lancer_chrono(self.temps_max)

        if j["est_ia"]:
            self._activer_clavier(False)
            Clock.schedule_once(lambda dt: self._ia_jouer_solo(), random.uniform(1.0, 2.2))

    def _traiter_lettre_solo(self, lettre: str):
        if not self.est_mon_tour:
            return
        nouvelle_seq = self.sequence + normaliser(lettre)
        possibilites = self._chercher_possibilites(nouvelle_seq)

        if not possibilites:
            self._flash_sequence(invalide=True)
            self.sequence = nouvelle_seq
            self.joueur_fautif = self.joueur_id
            snap = {"sequence": nouvelle_seq, "joueur_actuel": self.joueur_id,
                    "joueurs": self.joueurs_solo, "config": {"vies": self.vies_depart}}
            self._sync_etat(snap)
            self._toast("âš ï¸ SÃ©quence invalide â€” l'IA peut demander langue au chat", "warn")
            self._passer_suivant_solo()
            return

        self.sequence = nouvelle_seq
        match = self._est_complet(nouvelle_seq)

        if match:
            if match["nom_normalise"] in self.pays_joues:
                self._toast(f"ğŸ” {match['nom']} dÃ©jÃ  jouÃ© ! Tu perds une vie.", "error")
                self._perdre_vie_solo(self.joueur_id, "Pays dÃ©jÃ  jouÃ©")
                return

            self.pays_joues.add(match["nom_normalise"])
            self.pays_joues_liste.append(match)
            self._ajouter_drapeau(match)
            self._flash_sequence(complet=True)
            self._toast(f"ğŸ’€ Tu as complÃ©tÃ© {match['nom']} â€” tu perds une vie !", "warn")
            Clock.schedule_once(lambda dt: self._perdre_vie_solo(self.joueur_id, "Mot complet"), 1.5)
        else:
            snap = {"sequence": nouvelle_seq, "joueur_actuel": self.joueur_id,
                    "joueurs": self.joueurs_solo, "config": {"vies": self.vies_depart}}
            self._sync_etat(snap)
            self._passer_suivant_solo()

    def _ia_jouer_solo(self):
        seq = self.sequence
        possibilites = self._chercher_possibilites(seq)

        if not possibilites:
            # L'IA interpelle le joueur si c'est lui le fautif
            if self.joueur_fautif == self.joueur_id:
                Clock.schedule_once(
                    lambda dt: self._ouvrir_modal_langue("L'IA te demande : quel pays visais-tu ?"), 0
                )
            else:
                self._toast("ğŸ¤– L'IA donne sa langue au chat ! Elle perd une vie.", "warn")
                self._perdre_vie_solo("ia", "IA piÃ©gÃ©e")
            return

        # StratÃ©gie : Ã©vite de complÃ©ter si possible
        cibles = [p for p in possibilites if len(p["nom_normalise"]) > len(seq) + 1]
        if not cibles:
            cibles = possibilites

        cible = random.choice(cibles)
        lettre_suivante = cible["nom_normalise"][len(seq)]
        nouvelle_seq = seq + lettre_suivante
        self.sequence = nouvelle_seq
        self.joueur_fautif = "ia"

        match = self._est_complet(nouvelle_seq)
        if match:
            if match["nom_normalise"] in self.pays_joues:
                self._toast(f"ğŸ” L'IA a jouÃ© {match['nom']} dÃ©jÃ  jouÃ© ! Elle perd une vie.", "warn")
                Clock.schedule_once(lambda dt: self._perdre_vie_solo("ia", "Pays dÃ©jÃ  jouÃ©"), 0.5)
                return
            self.pays_joues.add(match["nom_normalise"])
            self.pays_joues_liste.append(match)
            self._ajouter_drapeau(match)
            snap = {"sequence": nouvelle_seq, "joueur_actuel": "ia",
                    "joueurs": self.joueurs_solo, "config": {"vies": self.vies_depart}}
            self._sync_etat(snap)
            self._flash_sequence(complet=True)
            self._toast(f"ğŸ’€ L'IA a complÃ©tÃ© {match['nom']} â€” elle perd une vie !", "warn")
            Clock.schedule_once(lambda dt: self._perdre_vie_solo("ia", "Mot complet"), 1.5)
        else:
            snap = {"sequence": nouvelle_seq, "joueur_actuel": "ia",
                    "joueurs": self.joueurs_solo, "config": {"vies": self.vies_depart}}
            self._sync_etat(snap)
            self._passer_suivant_solo()

    def _demander_langue_locale(self):
        """Le joueur demande une langue au chat Ã  l'IA."""
        seq = self.sequence
        possibilites = self._chercher_possibilites(seq)
        if possibilites:
            pays = random.choice(possibilites)
            self._afficher_verdict({
                "valide": True,
                "message": f"L'IA rÃ©pond : Â« {pays['nom']} Â». Valide ! Tu perds une vie."
            })
            self.pays_joues.add(pays["nom_normalise"])
            self.pays_joues_liste.append(pays)
            self._ajouter_drapeau(pays)
            Clock.schedule_once(lambda dt: self._perdre_vie_solo(self.joueur_id, "Langue au chat perdue"), 0.5)
        else:
            self._afficher_verdict({"valide": False, "message": "L'IA ne trouve rien ! Elle perd une vie."})
            Clock.schedule_once(lambda dt: self._perdre_vie_solo("ia", "IA sans rÃ©ponse"), 0.5)

    def _evaluer_reponse_locale(self, pays_propose: str):
        norm = normaliser(pays_propose)
        match = next((p for p in self.pays_local if p["nom_normalise"] == norm), None)

        if not match:
            self._afficher_verdict({"valide": False,
                "message": f"Â« {pays_propose} Â» n'existe pas ! Tu perds une vie."})
            Clock.schedule_once(lambda dt: self._perdre_vie_solo(self.joueur_id, "Pays inexistant"), 0.5)
        elif match["nom_normalise"] in self.pays_joues:
            self._afficher_verdict({"valide": False,
                "message": f"{match['nom']} a dÃ©jÃ  Ã©tÃ© jouÃ© ! Tu perds une vie."})
            Clock.schedule_once(lambda dt: self._perdre_vie_solo(self.joueur_id, "Pays dÃ©jÃ  jouÃ©"), 0.5)
        else:
            self.pays_joues.add(match["nom_normalise"])
            self.pays_joues_liste.append(match)
            self._ajouter_drapeau(match)
            self._afficher_verdict({"valide": True,
                "message": f"âœ… {match['nom']} est valide ! L'IA perd une vie."})
            Clock.schedule_once(lambda dt: self._perdre_vie_solo("ia", "Langue au chat perdue"), 0.5)

    def _perdre_vie_solo(self, joueur_id: str, raison: str):
        if self._chrono_event:
            self._chrono_event.cancel()

        j = next((x for x in self.joueurs_solo if x["id"] == joueur_id), None)
        if not j:
            return

        j["vies"] -= 1
        if j["vies"] <= 0:
            j["vies"] = 0
            j["en_vie"] = False

        vivants = [x for x in self.joueurs_solo if x["en_vie"]]
        if len(vivants) <= 1:
            Clock.schedule_once(lambda dt: self._afficher_fin_solo(vivants[0] if vivants else None), 0.8)
            return

        # Celui qui perd repart
        self.index_tour = self.joueurs_solo.index(j)
        Clock.schedule_once(lambda dt: self._nouveau_tour_solo(), 0.8)

    def _passer_suivant_solo(self):
        n = len(self.joueurs_solo)
        for _ in range(n):
            self.index_tour = (self.index_tour + 1) % n
            if self.joueurs_solo[self.index_tour]["en_vie"]:
                break
        Clock.schedule_once(lambda dt: self._nouveau_tour_solo(), 0.15)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  FIN DE PARTIE
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _afficher_fin(self, msg: dict):
        if self._chrono_event:
            self._chrono_event.cancel()
        gagnant = next((j for j in msg.get("joueurs", []) if j["id"] == msg.get("gagnant")), None)
        self.nom_gagnant = gagnant["nom"] if gagnant else "â€”"
        ecran = self.root.get_screen("fin")
        ecran.ids.stat_pays.text  = str(len(msg.get("pays_joues", [])))
        ecran.ids.stat_tours.text = str(self.nb_tours)
        ecran.ids.stat_vies.text  = str(gagnant["vies"] if gagnant else 0)
        Clock.schedule_once(lambda dt: self._aller_ecran("fin"), 0.6)

    def _afficher_fin_solo(self, gagnant):
        if self._chrono_event:
            self._chrono_event.cancel()
        self.nom_gagnant = gagnant["nom"] if gagnant else "â€”"
        ecran = self.root.get_screen("fin")
        ecran.ids.stat_pays.text  = str(len(self.pays_joues_liste))
        ecran.ids.stat_tours.text = str(self.nb_tours)
        ecran.ids.stat_vies.text  = str(gagnant["vies"] if gagnant else 0)
        self._aller_ecran("fin")

    def retour_accueil(self):
        if self._chrono_event:
            self._chrono_event.cancel()
        if self.ws:
            self._run_async(self.ws.close())
            self.ws = None
        self._aller_ecran("accueil")

    def rejouer(self):
        if self._chrono_event:
            self._chrono_event.cancel()
        if self.mode_connecte:
            self.retour_accueil()
        else:
            self._lancer_mode_solo()
            Clock.schedule_once(lambda dt: self._demarrer_solo(), 0.3)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  NAVIGATION
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _aller_ecran(self, nom: str):
        self.root.current = nom

    def _ajouter_chat(self, msg: dict):
        pass  # Chat visuel non implÃ©mentÃ© sur mobile (popup si besoin)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  LANCEMENT
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if __name__ == "__main__":
    PaysGameApp().run()